<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Intel® QAT Data Compression API &mdash; Intel® QuickAssist Technology  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/qat.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Revision History" href="revision_history.html" />
    <link rel="prev" title="Intel® QAT Cryptographic API" href="QAT_cryptoAPI.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Intel® QuickAssist Technology
          </a>
              <div class="version">
                Hardware Version 2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../qat_general/legal.html">Legal Notices &amp; Disclaimers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intro/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Intro/terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RN/In-Tree/index.html">Release Notes - In-Tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RN/Linux/2.X/index.html">Release Notes - Linux*</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RN/VMware/2.X/index.html">Release Notes - VMware*</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GSG/2.X/index.html">Getting Started Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PG/index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../VIRT/index.html">Virtualization Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PERF/index.html">Performance Optimization Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qatlib/index.html">QATlib User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AppNotes/index.html">Application Notes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API Programmer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="baseAPI.html">Base API and API Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="QAT_cryptoAPI.html">Intel® QAT Cryptographic API</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Intel® QAT Data Compression API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sessions">Sessions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#stateful-data-compression">Stateful Data Compression</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#session-establishment">Session Establishment</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#stateless-data-compression">Stateless Data Compression</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stateless-data-compression-using-multiple-compress-operations">Stateless Data Compression Using Multiple Compress Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-compression-data-plane-api">Data Compression Data Plane API</a></li>
<li class="toctree-l3"><a class="reference internal" href="#chained-hash-and-stateless-compression">Chained Hash and Stateless Compression</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="revision_history.html">Revision History</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../qat_general/contact.html">Contact &amp; Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../qat_general/collateral_list.html">Documentation &amp; Resources</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Intel® QuickAssist Technology</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">API Programmer’s Guide</a></li>
      <li class="breadcrumb-item active">Intel® QAT Data Compression API</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="intel-qat-data-compression-api">
<span id="qat-api-programmers-guide-qat-compressionapi"></span><h1>Intel® QAT Data Compression API<a class="headerlink" href="#intel-qat-data-compression-api" title="Permalink to this heading"></a></h1>
<p>This section describes the sample code for the Intel® QuickAssist Technology Data
Compression API, beginning with an API overview, and followed by descriptions of
various scenarios to illustrate the usage of the API.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This document does not cover data integrity concepts. Refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>
(<em>Programmer’s Guide</em>, Compress and Verify (CnV) related APIs) for your product for important
information on data integrity concepts, including the Compress-and-Verify feature.</p>
</div>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>The Intel® QuickAssist Technology Data Compression API can be categorized into
three broad areas as follows:</p>
<ul>
<li><p><strong>Common:</strong> This includes functionality for the initialization and shutdown of the
service.</p></li>
<li><p><strong>Instance Management:</strong> A given implementation of the API can present multiple
instances of the compression service, each representing a logical or virtual <em>device</em>.
Request order is guaranteed within a given instance of the service.</p></li>
<li><p><strong>Transformation:</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>Compression functionality</p></li>
<li><p>Decompression functionality</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>These areas of functionality are defined in <code class="docutils literal notranslate"><span class="pre">cpa_dc.h</span></code> and <code class="docutils literal notranslate"><span class="pre">cpa_dc_dp.h</span></code>.</p>
<p>The Intel® QAT Data Compression API uses the base API, which defines base data types used across
all services of the Intel® QAT API.</p>
<section id="sessions">
<h3>Sessions<a class="headerlink" href="#sessions" title="Permalink to this heading"></a></h3>
<p>Similar to the symmetric cryptography API, the data compression API has the concept
of a session. In the case of the compression API, a session is an object that describes
the compression parameters to be applied across several requests. These requests
might submit buffers within a single file, or buffers associated with a particular data
stream or flow. A session object is described by the following:</p>
<ul>
<li><p><strong>The compression level:</strong> Lower levels provide faster compression and the cost of
compression ratio, whereas higher levels provide a better compression ratio as the
cost of performance.</p></li>
<li><p><strong>The compression algorithm:</strong> Compression algorithm to use (e.g. deflate) and what type of Huffman trees
to use (static or dynamic).</p></li>
<li><p><strong>The session direction:</strong> If all requests on this session are compression requests,
then the direction can be set to compress (and similarly, for decompress). A
combined direction is also available if both compression and decompression
requests are called using the same session.</p></li>
<li><p><strong>The session state:</strong> A session can be described as <em>stateful</em> or <em>stateless</em>. Stateful
sessions maintain history and state between calls to the API, and stateless sessions
do not.</p>
<blockquote>
<div><ul class="simple">
<li><p>Stateless compression does not require history data from a previous
compression/decompression request to be restored before submitting the
request. Stateless sessions are used when the output data is known to be
constrained in size. An overflow condition (when the output data is about to
exceed the output buffer) is treated as an error condition in the
decompression direction. In the compression direction, the application can
keep submitting data from where the overflow was registered in the input
stream. The Data Plane API treats overflow as an error. In this case, the
overflow is treated as an error rather than an exception. The client application
is required to resubmit the job in its entirety with a larger output buffer.
Requests are treated independently; state and history are not saved and
restored between calls.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>When using a stateless session, it is possible to feed a seed checksum to the
<code class="docutils literal notranslate"><span class="pre">cpaDcCompressData()</span></code> or the <code class="docutils literal notranslate"><span class="pre">cpaDcDecompressData()</span></code> API when the <code class="docutils literal notranslate"><span class="pre">CPA_DC_FLUSH_FULL</span></code>
flush flag is used. The user application is responsible for maintaining the checksum across
requests. This feature is also known as <em>Stateful Lite</em>.</p>
<p>Stateful sessions are required when the data to be decompressed is larger
than the buffers being used. This is a standard mode of operation for
applications such as GZIP, where the size of the uncompressed data is not
known before execution, and therefore the destination buffer may not be large
enough to hold the resultant output. Requests to stateful sessions are not
treated independently, and state and history can be saved and restored
between calls. The amount of history and state carried between calls depends
on the compression level. For stateful decompression, only one outstanding
request may be in-flight at any one time for that session.</p>
</section>
</section>
<section id="stateful-data-compression">
<h2>Stateful Data Compression<a class="headerlink" href="#stateful-data-compression" title="Permalink to this heading"></a></h2>
<p>This example demonstrates the usage of the synchronous API, specifically using this
API to perform a compression operation. It compresses a file via a stateful session
using the deflate compress algorithm with static Huffman trees and using GZIP style
headers and footers.</p>
<p>These samples are located in <code class="docutils literal notranslate"><span class="pre">/dc/stateful_sample</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Stateful data compression is not available in Intel® QAT v1.8 and later releases.
However, stateful decompression is available in Intel® QAT v1.8 and later releases.</p>
</div>
<section id="session-establishment">
<h3>Session Establishment<a class="headerlink" href="#session-establishment" title="Permalink to this heading"></a></h3>
<p>This is the main entry point for the sample compression code. It demonstrates the
sequence of calls to be made to the API to create a session, perform one or more
compress operations, and then tear down the session. At this point, the instance has
been discovered and started, and the capabilities of the instance have been queried
and found to be suitable.</p>
<p>A session is established by describing a session, determining how much session
memory is required, and then invoking the session initialization function
<code class="docutils literal notranslate"><span class="pre">cpaDcInitSession</span></code>. See below example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sd</span><span class="p">.</span><span class="n">compLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_L4</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">compType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DEFLATE</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">huffType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_HT_STATIC</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">sessDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DIR_COMBINED</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">sessState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_STATEFUL</span><span class="p">;</span>
<span class="cp">#if (CPA_DC_API_VERSION_NUM_MAJOR == 1 &amp;&amp; CPA_DC_API_VERSION_NUM_MINOR &lt; 6)</span>
<span class="n">sd</span><span class="p">.</span><span class="n">deflateWindowSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">sd</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CRC32</span><span class="p">;</span>

<span class="cm">/* Determine size of session context to allocate */</span>
<span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcGetSessionSize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcGetSessionSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sess_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx_size</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate session memory */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">sess_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ctx_size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate context bufferlist */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcBufferListGetMetaSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffMetaSize</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferMeta</span><span class="p">,</span><span class="w"> </span><span class="n">buffMetaSize</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OS_MALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferCtx</span><span class="p">,</span><span class="w"> </span><span class="n">bufferListMemSize</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCtxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">ctx_size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pFlatBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">CpaFlatBuffer</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">pBufferCtx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">pBufferCtx</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pFlatBuffer</span><span class="p">;</span>
<span class="w">        </span><span class="n">pBufferCtx</span><span class="o">-&gt;</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">pBufferCtx</span><span class="o">-&gt;</span><span class="n">pPrivateMetaData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pBufferMeta</span><span class="p">;</span>
<span class="w">        </span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx_size</span><span class="p">;</span>
<span class="w">        </span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pCtxBuf</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Initialize the Stateful session */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcInitSession</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcInitSession</span><span class="p">(</span><span class="n">d</span>
<span class="w">            </span><span class="n">cInstHandle</span><span class="p">,</span>
<span class="w">            </span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Session memory */</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Session setup data */</span>
<span class="w">            </span><span class="n">pBufferCtx</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Context buffer */</span>
<span class="w">            </span><span class="nb">NULL</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Callback function NULL for sync mode */</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Source and destination buffers must be established.</p>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Only using 1 buffer in this case */</span>

<span class="cm">/* Allocate memory for bufferlist and array of flat buffers in a contiguous</span>
<span class="cm"> * area and carve it up to reduce number of memory allocations required. */</span>
<span class="n">bufferListMemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaBufferList</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaFlatBuffer</span><span class="p">));</span>

<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcBufferListGetMetaSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferMetaSize</span><span class="p">);</span>

<span class="cm">/* Allocate source buffer */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferMetaSrc</span><span class="p">,</span><span class="w"> </span><span class="n">bufferMetaSize</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OS_MALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferListSrc</span><span class="p">,</span><span class="w"> </span><span class="n">bufferListMemSize</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pSrcBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate destination buffer the same size as source buffer */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferMetaDst</span><span class="p">,</span><span class="w"> </span><span class="n">bufferMetaSize</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OS_MALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferListDst</span><span class="p">,</span><span class="w"> </span><span class="n">bufferListMemSize</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pDstBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Build source bufferList */</span>
<span class="w">    </span><span class="n">pFlatBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">CpaFlatBuffer</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">pBufferListSrc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pFlatBuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pPrivateMetaData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pBufferMetaSrc</span><span class="p">;</span>

<span class="w">    </span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pSrcBuffer</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Build destination bufferList */</span>
<span class="w">    </span><span class="n">pFlatBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">CpaFlatBuffer</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">pBufferListDst</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="n">pBufferListDst</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pFlatBuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListDst</span><span class="o">-&gt;</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListDst</span><span class="o">-&gt;</span><span class="n">pPrivateMetaData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pBufferMetaDst</span><span class="p">;</span>

<span class="w">    </span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pDstBuffer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At this point, the application has opened an instance, established a session, and
allocated buffers. It is time to start some compress operations. To produce GZIP style
compressed files, the first thing that needs to be performed is header generation.
Create a header using the following code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Write RFC1952 gzip header to destination buffer */</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcGenerateHeader</span><span class="p">(</span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">pFlatBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hdr_sz</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Write out header */</span>
<span class="w">    </span><span class="n">fwrite</span><span class="p">(</span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">hdr_sz</span><span class="p">,</span><span class="w"> </span><span class="n">dstFile</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cpaDcGenerateHeader</span></code> produces a GZIP style header (compliant with GZIP file format
specification v4.3, RFC 1952, refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>) when the session set up data is set
such that <code class="docutils literal notranslate"><span class="pre">compType</span></code> is <code class="docutils literal notranslate"><span class="pre">CPA_DC_DEFLATE</span></code> and checksum is <code class="docutils literal notranslate"><span class="pre">CPA_DC_CRC32</span></code>.</p>
<p>Alternatively, a zlib style header (compliant with ZLIB Compressed Data Format
Specification, v3.3, RFC 1950, refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>) can be produced if the session setup data is
set such that <code class="docutils literal notranslate"><span class="pre">compType</span></code> is <code class="docutils literal notranslate"><span class="pre">CPA_DC_DEFLATE</span></code> and checksum is <code class="docutils literal notranslate"><span class="pre">CPA_DC_ADLER32</span></code>. This operation
demonstrates looping through a file, reading the data, invoking the data compress operation,
and writing the results to the output file.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">srcFile</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Read from file into src buffer */</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pSrcBuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">fread</span><span class="p">(</span><span class="n">pSrcBuffer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">,</span><span class="w"> </span><span class="n">srcFile</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">flush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_FLUSH_FINAL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">flush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_FLUSH_SYNC</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcCompressData</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcCompressData</span><span class="p">(</span>
<span class="w">                </span><span class="n">dcInstHandle</span><span class="p">,</span>
<span class="w">                </span><span class="n">sessionHdl</span><span class="p">,</span>
<span class="w">                </span><span class="n">pBufferListSrc</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Source buffer list */</span>
<span class="w">                </span><span class="n">pBufferListDst</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Destination buffer list */</span>
<span class="w">                </span><span class="o">&amp;</span><span class="n">dcResults</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Results structure */</span>
<span class="w">                </span><span class="n">flush</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Stateful session */</span>
<span class="w">                </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;cpaDcCompressData failed. (status = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* We now check the results */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CPA_DC_OK</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CPA_DC_OVERFLOW</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Results status not as expected (status = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">fwrite</span><span class="p">(</span><span class="n">pDstBuffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">produced</span><span class="p">,</span><span class="w"> </span><span class="n">dstFile</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="p">;</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pSrcBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CPA_DC_OVERFLOW</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, a GZIP footer is generated. Similar to the call to <code class="docutils literal notranslate"><span class="pre">cpaDcGenerateHeader</span></code>, a
GZIP footer compliant with GZIP style header (compliant with GZIP file format
specification v4.3, RFC 1952, refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>) is produced because the session setup
data is set such that <code class="docutils literal notranslate"><span class="pre">compType</span></code> is <code class="docutils literal notranslate"><span class="pre">CPA_DC_DEFLATE</span></code> and checksum is <code class="docutils literal notranslate"><span class="pre">CPA_DC_CRC32</span></code>.</p>
<p>The call to <code class="docutils literal notranslate"><span class="pre">cpaDcGenerateFooter</span></code> increments the produced field of the
<code class="docutils literal notranslate"><span class="pre">CpaDcRqResults</span></code> structure by the size of the footer added. In this example, the data
produced so far has already been written out to the file. As such, the produced field of
the <code class="docutils literal notranslate"><span class="pre">CpaDcRqResults</span></code> structure is cleared before calling the <code class="docutils literal notranslate"><span class="pre">cpaDcGenerateFooter</span></code>
function.</p>
<p>In the event the destination buffer would be too small to accept the footer, the
<code class="docutils literal notranslate"><span class="pre">cpaDcGenerateFooter()</span></code> API will return an invalid parameter error. The
<code class="docutils literal notranslate"><span class="pre">cpaDcGenerateFooter()</span></code> API cannot return an overflow exception. It is the application’s
responsibility to ensure that there is enough allocated buffer memory to append the
algorithm specific footer.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dcResults</span><span class="p">.</span><span class="n">produced</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="cm">/* Write RFC1952 gzip footer to destination buffer */</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcGenerateFooter</span><span class="p">(</span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">pFlatBuffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dcResults</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Write out footer */</span>
<span class="w">    </span><span class="n">fwrite</span><span class="p">(</span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">produced</span><span class="p">,</span><span class="w"> </span><span class="n">dstFile</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because this session was created with <code class="docutils literal notranslate"><span class="pre">CPA_DC_DIR_COMBINED</span></code> it can also be used to
decompress data.</p>
<p>The stateful decompression operation demonstrates looping through a file, reading
the compressed data, invoking the data decompress operation, and writing the results
to the output file. In this case, the overflow condition has to be considered. See below example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">srcFile</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Read from file into src buffer */</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pSrcBuffer</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">fread</span><span class="p">(</span><span class="n">pSrcBuffer</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">,</span><span class="w"> </span><span class="n">srcFile</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SAMPLE_BUFF_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* FLUSH FINAL flag must be set for last request */</span>
<span class="w">        </span><span class="n">opData</span><span class="p">.</span><span class="n">flushFlag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_FLUSH_FINAL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* FLUSH SYNC flag must be set for intermediate requests */</span>
<span class="w">        </span><span class="n">opData</span><span class="p">.</span><span class="n">flushFlag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_FLUSH_SYNC</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcDecompressData2</span><span class="p">(</span>
<span class="w">            </span><span class="n">dcInstHandle</span><span class="p">,</span>
<span class="w">            </span><span class="n">sessionHdl</span><span class="p">,</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Source buffer list */</span>
<span class="w">            </span><span class="n">pBufferListDst</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Destination buffer list */</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">opData</span><span class="p">,</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">dcResults</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Results structure */</span>
<span class="w">            </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;cpaDcDecompressData2 failed. (status = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* We now check the results - in decompress direction the</span>
<span class="cm">         * output buffer may overflow */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CPA_DC_OK</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CPA_DC_OVERFLOW</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Results status not as expected (status = %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* The gzip file generated by Deflate algorithm has an 8-byte</span>
<span class="cm">         * footer, containing a CRC-32 checksum and the length of the</span>
<span class="cm">         * original uncompressed data. The &#39;endOfLastBlock&#39; flag tells</span>
<span class="cm">         * if we have processed the last data block. Break the loop</span>
<span class="cm">         * here, otherwise it will keep on reading gzip file */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_TRUE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">endOfLastBlock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="p">;</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dcResults</span><span class="p">.</span><span class="n">consumed</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pSrcBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dcResults</span><span class="p">.</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CPA_DC_OVERFLOW</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once all operations on this session have been completed, the session is torn down
as shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sessionStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcRemoveSession</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sessionHdl</span><span class="p">);</span>
</pre></div>
</div>
<p>Query statistics at this point, which can be useful for debugging.</p>
<p>Finally, clean up by freeing up memory, stopping the instance, etc.</p>
</section>
</section>
<section id="stateless-data-compression">
<h2>Stateless Data Compression<a class="headerlink" href="#stateless-data-compression" title="Permalink to this heading"></a></h2>
<p>This example demonstrates the usage of the asynchronous API, specifically using this
API to perform a compression operation. It compresses a data buffer through a
stateless session using the deflate compress algorithm with dynamic Huffman trees.</p>
<p>The example below compresses a block of data into a compressed block.</p>
<p>These samples are located in <code class="docutils literal notranslate"><span class="pre">/dc/stateless_sample</span></code>.</p>
<p>In the below example, dynamic Huffman trees are used. The instance can be queried to
ensure dynamic Huffman trees are supported, and if an instance-specific buffer is
required to perform a dynamic Huffman tree deflate request.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcQueryCapabilities</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CPA_STATUS_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">statelessDeflateCompression</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">statelessDeflateDecompression</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">checksumAdler32</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">dynamicHuffman</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;Error: Unsupported functionality</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">dynamicHuffmanBufferReq</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcBufferListGetMetaSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffMetaSize</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcGetNumIntermediateBuffers</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">numInterBuffLists</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">numInterBuffLists</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferInterArray</span><span class="p">,</span><span class="w"> </span><span class="n">numInterBuffLists</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaBufferList</span><span class="w"> </span><span class="o">*</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">bufferNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bufferNum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numInterBuffLists</span><span class="p">;</span><span class="w"> </span><span class="n">bufferNum</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferInterArray</span><span class="p">[</span><span class="n">bufferNum</span><span class="p">],</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaBufferList</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferInterArray</span><span class="p">[</span><span class="n">bufferNum</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pPrivateMetaData</span><span class="p">,</span><span class="w"> </span><span class="n">buffMetaSize</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferInterArray</span><span class="p">[</span><span class="n">bufferNum</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaFlatBuffer</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* Implementation requires an intermediate buffer approximately twice the size of the output buffer */</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufferInterArray</span><span class="p">[</span><span class="n">bufferNum</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">SAMPLE_MAX_BUFF</span><span class="p">);</span>
<span class="w">            </span><span class="n">bufferInterArray</span><span class="p">[</span><span class="n">bufferNum</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="n">bufferInterArray</span><span class="p">[</span><span class="n">bufferNum</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">SAMPLE_MAX_BUFF</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/* End numInterBuffLists */</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Set the address translation function for the instance */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcSetAddressTranslation</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Start DataCompression component */</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcStartInstance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcStartInstance</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">numInterBuffLists</span><span class="p">,</span><span class="w"> </span><span class="n">bufferInterArray</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The create and initialize stateless session demonstrates the sequence of calls to be
made to the API to create a session. To establish a session, describing the session must be done followed by
determining how much session memory is required, and then invoke the session
initialization function <code class="docutils literal notranslate"><span class="pre">cpaDcInitSession</span></code>. See below example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sd</span><span class="p">.</span><span class="n">compLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_L4</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">compType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DEFLATE</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">huffType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_HT_FULL_DYNAMIC</span><span class="p">;</span>

<span class="cm">/* If the implementation supports it, the session will be configured</span>
<span class="cm"> * to select static Huffman encoding over dynamic Huffman as</span>
<span class="cm"> * the static encoding will provide better compressibility */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_TRUE</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">sd</span><span class="p">.</span><span class="n">sessDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DIR_COMBINED</span><span class="p">;</span>
<span class="n">sd</span><span class="p">.</span><span class="n">sessState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_STATELESS</span><span class="p">;</span>
<span class="cp">#if (CPA_DC_API_VERSION_NUM_MAJOR == 1 &amp;&amp; CPA_DC_API_VERSION_NUM_MINOR &lt; 6)</span>
<span class="n">sd</span><span class="p">.</span><span class="n">deflateWindowSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">sd</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_ADLER32</span><span class="p">;</span>

<span class="cm">/* Determine size of session context to allocate */</span>
<span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcGetSessionSize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcGetSessionSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sess_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx_size</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate session memory */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">sess_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize the Stateless session */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcInitSession</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcInitSession</span><span class="p">(</span>
<span class="w">            </span><span class="n">dcInstHandle</span><span class="p">,</span>
<span class="w">            </span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Session memory */</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Session setup data */</span>
<span class="w">            </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="cm">/* pContexBuffer not required for stateless operations */</span>
<span class="w">            </span><span class="n">dcCallback</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Callback function */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Source and destination buffers are allocated in a similar way to the stateful example
above.</p>
<p><strong>Perform Operation:</strong> This example demonstrates invoking the data compress operation,
in the stateless case.</p>
<p>Once all operations on this session have been completed, the session is torn down
as shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sessionStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcRemoveSession</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sessionHdl</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="stateless-data-compression-using-multiple-compress-operations">
<h2>Stateless Data Compression Using Multiple Compress Operations<a class="headerlink" href="#stateless-data-compression-using-multiple-compress-operations" title="Permalink to this heading"></a></h2>
<p>This example demonstrates the use of the asynchronous API, specifically, using this
API to perform a compression operation. It compresses a data buffer using multiple
stateless compression API requests and maintains length and checksum information
across the multiple requests without the overhead of maintaining full history
information as used in a stateful operation.</p>
<p>The samples are located in <code class="docutils literal notranslate"><span class="pre">/dc/stateless_multi_op_checksum_sample</span></code>.</p>
<p>In this sample, session creation is the same as for regular stateless operation. Refer to
the previous sample for details.</p>
<p><strong>Perform Operation:</strong> This example demonstrates the invoking of the data compress
operation in the stateless case while maintaining checksum information across
multiple compress operations. The key points to note are:</p>
<ul>
<li><p>The initial value of <code class="docutils literal notranslate"><span class="pre">dcResults.checksum</span></code> is set to <code class="docutils literal notranslate"><span class="pre">0</span></code> for CRC32 or set to <code class="docutils literal notranslate"><span class="pre">1</span></code> for Adler32
when invoking the first compress or decompress operation for a data set.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CPA_DC_ADLER32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Initialize checksum to 1 for Adler32 */</span>
<span class="w">    </span><span class="n">dcResults</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Initialize checksum to 0 for CRC32 */</span>
<span class="w">    </span><span class="n">dcResults</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>The value of <code class="docutils literal notranslate"><span class="pre">dcResults.checksum</span></code> when invoking a subsequent compress operation
for a data set is set to the <code class="docutils literal notranslate"><span class="pre">dcResults</span></code>. Checksum value returned from the previous
compress operation on that data set.</p></li>
</ul>
</section>
<section id="data-compression-data-plane-api">
<span id="qat-api-programmers-guide-qat-compressionapi-dcdataplaneapi"></span><h2>Data Compression Data Plane API<a class="headerlink" href="#data-compression-data-plane-api" title="Permalink to this heading"></a></h2>
<p>This example demonstrates the usage of the data plane data compression API to
perform a compression operation. It compresses a data buffer via a stateless session
using the deflate compress algorithm with dynamic Huffman trees. This example is
simplified to demonstrate the basics of how to use the API and how to build the
structures required. This example does not demonstrate the optimal way to use the
API to get maximum performance for a particular implementation. Refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>
for implementation specific documentation and performance sample code for a guide on
how to use the API for best performance.</p>
<p>These samples are located in <code class="docutils literal notranslate"><span class="pre">/dc/dc_dp_sample</span></code>.</p>
<p>The data plane data compression API is used in a similar way to the data plane symmetric cryptographic API:</p>
<ul class="simple">
<li><p>Data compression service instances are queried and started in the same way and
using the same functions as before (see example in
<a class="reference internal" href="baseAPI.html#qat-api-programmers-guide-baseapi-instancediscovery"><span class="std std-ref">Instance Discovery</span></a>).</p></li>
</ul>
<p>The below example registers a callback function for the data compression instance.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcDpRegCbFunc</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">dcDpCallback</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, create and initialize a session a shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">compLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_L4</span><span class="p">;</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">compType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DEFLATE</span><span class="p">;</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">huffType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_HT_FULL_DYNAMIC</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* If the implementation supports it, the session will be configured</span>
<span class="cm">     * to select static Huffman encoding over dynamic Huffman as</span>
<span class="cm">     * the static encoding will provide better compressibility */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sd</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_TRUE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sd</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_FALSE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">sessDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DIR_COMBINED</span><span class="p">;</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">sessState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_STATELESS</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#if (CPA_DC_API_VERSION_NUM_MAJOR == 1 &amp;&amp; CPA_DC_API_VERSION_NUM_MINOR &lt; 6)</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">deflateWindowSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">    </span><span class="n">sd</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CRC32</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Determine size of session context to allocate */</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcGetSessionSize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcGetSessionSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sess_size</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate session memory */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">sess_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize the Stateless session */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcDpInitSession</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcDpInitSession</span><span class="p">(</span>
<span class="w">            </span><span class="n">dcInstHandle</span><span class="p">,</span>
<span class="w">            </span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Session memory */</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">sd</span><span class="p">);</span><span class="w"> </span><span class="cm">/* Session setup data */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the following example, input and output data is stored in a scatter-gather list. The source
and destination buffers are described using the <code class="docutils literal notranslate"><span class="pre">CpaPhysBufferList</span></code> structure. In this
example the allocation (which needs to be 8-byte aligned) and setup of the source
buffer is shown. The destination buffers can be allocated and set up in a similar way.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="cm">/* Size of CpaPhysBufferList and array of CpaPhysFlatBuffers */</span>
<span class="n">bufferListMemSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaPhysBufferList</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaPhysFlatBuffer</span><span class="p">));</span>

<span class="cm">/* Allocate 8-byte aligned source buffer List */</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC_ALIGNED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferListSrc</span><span class="p">,</span><span class="w"> </span><span class="n">bufferListMemSize</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate first data buffer to hold half the data */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pSrcBuffer</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate second data buffer to hold half the data */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pSrcBuffer2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Copy source into buffer */</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pSrcBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">sampleData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pSrcBuffer2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">sampleData</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">]),</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Build source bufferList */</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">flatBuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">flatBuffers</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bufferPhysAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">(</span><span class="n">pSrcBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">flatBuffers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">dataLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">flatBuffers</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">bufferPhysAddr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">(</span><span class="n">pSrcBuffer2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The operational data in this case is shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Allocate memory for operational data. Note this needs to be</span>
<span class="cm"> * 8-byte aligned, contiguous, resident in DMA-accessible</span>
<span class="cm"> * memory */</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC_ALIGNED</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pOpData</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">CpaDcDpOpData</span><span class="p">),</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">bufferLenToCompress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">);</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">bufferLenForData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">sampleData</span><span class="p">);</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">dcInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dcInstHandle</span><span class="p">;</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">pSessionHandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sessionHdl</span><span class="p">;</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">srcBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">(</span><span class="n">pBufferListSrc</span><span class="p">);</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">srcBufferLen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DP_BUFLIST</span><span class="p">;</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">destBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">(</span><span class="n">pBufferListDst</span><span class="p">);</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">destBufferLen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DP_BUFLIST</span><span class="p">;</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">sessDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DIR_COMPRESS</span><span class="p">;</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">thisPhys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">(</span><span class="n">pOpData</span><span class="p">);</span>
<span class="w">    </span><span class="n">pOpData</span><span class="o">-&gt;</span><span class="n">pCallbackTag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This request is then enqueued and submitted on the instance as shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcDpEnqueueOp</span><span class="p">(</span><span class="n">pOpData</span><span class="p">,</span><span class="w"> </span><span class="n">CPA_TRUE</span><span class="p">);</span>
</pre></div>
</div>
<p>After possibly doing other work (e.g., enqueuing and submitting more requests),
the application can poll for responses that invoke the callback function registered
with the instance. Refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>
for implementation specific documentation on the implementations polling functions.</p>
<p>Once all requests associated with a session have been completed, the session can
be removed.</p>
<p>Clean up by freeing up memory, stopping the instance, etc. as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sessionStatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcDpRemoveSession</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sessionHdl</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="chained-hash-and-stateless-compression">
<h2>Chained Hash and Stateless Compression<a class="headerlink" href="#chained-hash-and-stateless-compression" title="Permalink to this heading"></a></h2>
<p>This example demonstrates the use of the asynchronous API, specifically, using the
data compression chain API to perform chained hash and stateless compression
operations. It performs a SHA-256 hash on the sample text and then compresses the
sample text through a stateless session using the deflate compress algorithm with
static Huffman trees.</p>
<p>These samples are located in <code class="docutils literal notranslate"><span class="pre">/dc/chaining_sample</span></code>.</p>
<p>The below example shows how to query and start a compression instance.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* In this simplified version of instance discovery, we discover</span>
<span class="cm"> * exactly one instance of a data compression service */</span>
<span class="n">sampleDcGetInstance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dcInstHandle</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dcInstHandle</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Get instance failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Query Capabilities */</span>
<span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcQueryCapabilities</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcQueryCapabilities</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">status</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CPA_STATUS_SUCCESS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Query capabilities failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_FALSE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CPA_BITMAP_BIT_TEST</span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">dcChainCapInfo</span><span class="p">,</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_HASH_THEN_COMPRESS</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Hash + compress chained operation is not supported on logical instance.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Please ensure Chaining related settings are enabled in the device configuration file.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">statelessDeflateCompression</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">checksumCRC32</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">cap</span><span class="p">.</span><span class="n">checksumAdler32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Error: Unsupported functionality</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Set the address translation function for the instance */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcSetAddressTranslation</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sampleVirtToPhys</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Start static data compression component */</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcStartInstance</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcStartInstance</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example shows how to create and initialize the session.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* If the instance is polled start the polling thread. Note that</span>
<span class="cm">     * how the polling is done is implementation-dependant */</span>
<span class="w">    </span><span class="n">sampleDcStartPolling</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* We now populate the fields of the session operational data and</span>
<span class="cm">     * create the session. Note that the size required to store a session is</span>
<span class="cm">     * implementation-dependent, so we query the API first to determine</span>
<span class="cm">     * how much memory to allocate, and then allocate that memory */</span>

<span class="w">    </span><span class="c1">// &lt;snippet name=&quot;initSession&quot;&gt;</span>

<span class="w">    </span><span class="cm">/* Initialize compression session data */</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">compLevel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_L1</span><span class="p">;</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">compType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DEFLATE</span><span class="p">;</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">huffType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_HT_STATIC</span><span class="p">;</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">autoSelectBestHuffmanTree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_FALSE</span><span class="p">;</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">sessDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_DIR_COMPRESS</span><span class="p">;</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">sessState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_STATELESS</span><span class="p">;</span>
<span class="w">    </span><span class="n">dcSessionData</span><span class="p">.</span><span class="n">checksum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CRC32</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Initialize crypto session data */</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">sessionPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_CY_PRIORITY_NORMAL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Hash operation on the source data */</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">symOperation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_CY_SYM_OP_HASH</span><span class="p">;</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">hashSetupData</span><span class="p">.</span><span class="n">hashAlgorithm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_CY_SYM_HASH_SHA256</span><span class="p">;</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">hashSetupData</span><span class="p">.</span><span class="n">hashMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_CY_SYM_HASH_MODE_PLAIN</span><span class="p">;</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">hashSetupData</span><span class="p">.</span><span class="n">digestResultLenInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GET_HASH_DIGEST_LENGTH</span><span class="p">(</span><span class="n">cySessionData</span><span class="p">.</span><span class="n">hashSetupData</span><span class="p">.</span><span class="n">hashAlgorithm</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Place the digest result in a buffer unrelated to srcBuffer */</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">digestIsAppended</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_FALSE</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Generate the digest */</span>
<span class="w">    </span><span class="n">cySessionData</span><span class="p">.</span><span class="n">verifyDigest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_FALSE</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Initialize chaining session data - hash + compression chain operation */</span>
<span class="w">    </span><span class="n">chainSessionData</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sessType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_SYMMETRIC_CRYPTO</span><span class="p">;</span>
<span class="w">    </span><span class="n">chainSessionData</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pCySetupData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cySessionData</span><span class="p">;</span>
<span class="w">    </span><span class="n">chainSessionData</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sessType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_COMPRESS_DECOMPRESS</span><span class="p">;</span>
<span class="w">    </span><span class="n">chainSessionData</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">pDcSetupData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dcSessionData</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Determine size of session context to allocate */</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcChainGetSessionSize</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcChainGetSessionSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_HASH_THEN_COMPRESS</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_SESSIONS_TWO</span><span class="p">,</span><span class="w"> </span><span class="n">chainSessionData</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sess_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate session memory */</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">sess_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Initialize the chaining session */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;cpaDcChainInitSession</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcChainInitSession</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sessionHdl</span><span class="p">,</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_HASH_THEN_COMPRESS</span><span class="p">,</span><span class="w"> </span><span class="n">NUM_SESSIONS_TWO</span><span class="p">,</span><span class="w"> </span><span class="n">chainSessionData</span><span class="p">,</span><span class="w"> </span><span class="n">dcCallback</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">cySessionData.digestIsAppended</span></code> should be always set to <code class="docutils literal notranslate"><span class="pre">CPA_FALSE</span></code> as the digest
must not appended at the end of output.</p>
</div>
<p>The next example shows the memory allocation for the chained hash and stateless compression.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcBufferListGetMetaSize</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferMetaSize</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Error get meta size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bufferSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sampleDataSize</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dcChainBuildBufferList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferListSrc</span><span class="p">,</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">,</span><span class="w"> </span><span class="n">bufferMetaSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* copy source data into buffer */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pFlatBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">CpaFlatBuffer</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">pBufferListSrc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">pFlatBuffer</span><span class="o">-&gt;</span><span class="n">pData</span><span class="p">,</span><span class="w"> </span><span class="n">sampleData</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate destination buffer the four times as source buffer */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dcChainBuildBufferList</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBufferListDst</span><span class="p">,</span><span class="w"> </span><span class="n">numBuffers</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">,</span><span class="w"> </span><span class="n">bufferMetaSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate digest result buffer to store hash value */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pDigestBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">GET_HASH_DIGEST_LENGTH</span><span class="p">(</span><span class="n">hashAlg</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following example sets up the operational data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dcOpData</span><span class="p">.</span><span class="n">flushFlag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_FLUSH_FINAL</span><span class="p">;</span>
<span class="n">dcOpData</span><span class="p">.</span><span class="n">compressAndVerify</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_TRUE</span><span class="p">;</span>
<span class="n">dcOpData</span><span class="p">.</span><span class="n">compressAndVerifyAndRecover</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_TRUE</span><span class="p">;</span>
<span class="n">cySymOpData</span><span class="p">.</span><span class="n">packetType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_CY_SYM_PACKET_TYPE_FULL</span><span class="p">;</span>
<span class="n">cySymOpData</span><span class="p">.</span><span class="n">hashStartSrcOffsetInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">cySymOpData</span><span class="p">.</span><span class="n">messageLenToHashInBytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">;</span>
<span class="n">cySymOpData</span><span class="p">.</span><span class="n">pDigestResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pDigestBuffer</span><span class="p">;</span>

<span class="cm">/* Set chaining operation data */</span>
<span class="n">chainOpData</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">opType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_SYMMETRIC_CRYPTO</span><span class="p">;</span>
<span class="n">chainOpData</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pCySymOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cySymOpData</span><span class="p">;</span>
<span class="n">chainOpData</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">opType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_DC_CHAIN_COMPRESS_DECOMPRESS</span><span class="p">;</span>
<span class="n">chainOpData</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">pDcOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dcOpData</span><span class="p">;</span>
</pre></div>
</div>
<p>Hash and stateless dynamic compression are also supported.
Refer to the previous examples to add dynamic compression released buffers and session data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Hash algorithms are not limited to SHA-1 and SHA-256. Refer to
<a class="reference internal" href="introduction.html#qat-api-programmers-guide-introduction-related-documentation-references"><span class="std std-ref">Related Documents and References</span></a>
(<em>Intel® QuickAssist Technology Software for Linux</em> Release Notes*) for any limitations on using other
hash algorithms in the current release.</p>
</div>
<p>The following example shows how to verify the output of the chained hash and stateless compression.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Use software to calculate digest and verify digest */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pSWDigestBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">GET_HASH_DIGEST_LENGTH</span><span class="p">(</span><span class="n">hashAlg</span><span class="p">));</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calSWDigest</span><span class="p">(</span><span class="n">sampleData</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">,</span><span class="w"> </span><span class="n">pSWDigestBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">GET_HASH_DIGEST_LENGTH</span><span class="p">(</span><span class="n">hashAlg</span><span class="p">),</span><span class="w"> </span><span class="n">hashAlg</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">pDigestBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">pSWDigestBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">GET_HASH_DIGEST_LENGTH</span><span class="p">(</span><span class="n">hashAlg</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Digest buffer does not match expected output</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;Digest buffer matches expected output</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">PHYS_CONTIG_FREE</span><span class="p">(</span><span class="n">pSWDigestBuffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Use zlib to decompress and verify integrity */</span>

<span class="c1">//&lt;snippet name=&quot;software decompress&quot;&gt;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">z_stream_s</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="n">Cpa8U</span><span class="w"> </span><span class="o">*</span><span class="n">pDecompBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">Cpa8U</span><span class="w"> </span><span class="o">*</span><span class="n">pHWCompBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">Cpa8U</span><span class="w"> </span><span class="o">*</span><span class="n">pSWCompBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">Cpa32U</span><span class="w"> </span><span class="n">bufferLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inflate_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PRINT</span><span class="p">(</span><span class="s">&quot;zlib stream initialize failed&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">bufferLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">numBuffers</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pBufferListSrc</span><span class="o">-&gt;</span><span class="n">pBuffers</span><span class="o">-&gt;</span><span class="n">dataLenInBytes</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pDecompBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">bufferLength</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pHWCompBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">bufferLength</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PHYS_CONTIG_ALLOC</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pSWCompBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">bufferLength</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">copyMultiFlatBufferToBuffer</span><span class="p">(</span><span class="n">pBufferListDst</span><span class="p">,</span><span class="w"> </span><span class="n">pHWCompBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inflate_decompress</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">pHWCompBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">bufferLength</span><span class="p">,</span><span class="w"> </span><span class="n">pDecompBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">bufferLength</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Decompress data on zlib stream failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CPA_STATUS_SUCCESS</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">status</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Compare with original Src buffer */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">pDecompBuffer</span><span class="p">,</span><span class="w"> </span><span class="n">sampleData</span><span class="p">,</span><span class="w"> </span><span class="n">bufferSize</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CPA_STATUS_FAIL</span><span class="p">;</span>
<span class="w">            </span><span class="n">PRINT_ERR</span><span class="p">(</span><span class="s">&quot;Decompression does not match source buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PRINT_DBG</span><span class="p">(</span><span class="s">&quot;Decompression matches source buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">inflate_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stream</span><span class="p">);</span>
<span class="w">    </span><span class="n">PHYS_CONTIG_FREE</span><span class="p">(</span><span class="n">pSWCompBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="n">PHYS_CONTIG_FREE</span><span class="p">(</span><span class="n">pHWCompBuffer</span><span class="p">);</span>
<span class="w">    </span><span class="n">PHYS_CONTIG_FREE</span><span class="p">(</span><span class="n">pDecompBuffer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once all operations on this session have been completed, the session is torn down
as shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpaDcChainRemoveSession</span><span class="p">(</span><span class="n">dcInstHandle</span><span class="p">,</span><span class="w"> </span><span class="n">sessionHdl</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="QAT_cryptoAPI.html" class="btn btn-neutral float-left" title="Intel® QAT Cryptographic API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="revision_history.html" class="btn btn-neutral float-right" title="Revision History" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Intel Corporation.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>